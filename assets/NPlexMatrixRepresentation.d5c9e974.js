import{_ as h,r as y,u as s,t as X,o as _,c as p,b as f,e as x,F as Y,A as g,f as b}from"./app.e44a84a6.js";import{f as d,m as R,a as q,s as r,v,b as N,c as C,d as T,e as l,S as o,g as P}from"./formatters.fdcfcd68.js";import{a as u}from"./common.af0f23a5.js";import"./monoids.4caa29cc.js";const k={name:"NPlexMatrixRepresentation",props:{value:{type:Number,default:2},diagonal:{type:Boolean,default:!1}},setup(t){const n=y({options:{parenthesis:"auto",implicit:"hide"},C:s(()=>t.diagonal?d(R(o)(t.value)):d(q(o)(t.value))),e:s(()=>{const e=r(t.diagonal?"f":"e",t.value);return v()(n.C)(e)}),x:s(()=>{const e=r(t.diagonal?"u":"x",t.value);return v()(n.C)(e)}),y:s(()=>{const e=r(t.diagonal?"v":"y",t.value);return N()(n.C)(e)}),X:s(()=>{const e=r(t.diagonal?"u":"x",t.value);return C(o)(n.C)(e)}),Y:s(()=>{const e=r(t.diagonal?"v":"y",t.value);return T(o)(n.C)(e)}),eqX:s(()=>{const e=l(n.X),a=t.diagonal?u("\\mathbf{X}(\\mathbf{u})"):u("\\mathbf{X}(\\mathbf{x})");return a.unescaped=!0,o.eq(a,l(e))}),eqY:s(()=>{const e=l(n.Y),a=t.diagonal?u("\\mathbf{Y}(\\mathbf{v})"):u("\\mathbf{Y}(\\mathbf{y})");return a.unescaped=!0,o.eq(a,e)}),eqXy:s(()=>{const e=n.X,a=n.y,c=o.mul(e,a);return o.eq(o.mul(l(e),a),l(c))}),eqxY:s(()=>{const e=n.x,a=n.Y,c=o.mul(e,a);return o.eq(o.mul(e,l(a)),l(c))})}),i=e=>e.toTex({parenthesis:n.options.parenthesis,implicit:n.options.implicit,handler:P});return{...X(n),toTex:i}}},B=g(" We can verify that this corresponds to the expected multiplication: ");function L(t,n,i,e,a,c){const m=b("formula");return _(),p(Y,null,[f("p",null,[x(m,{value:e.toTex(t.eqX)},null,8,["value"])]),f("p",null,[B,x(m,{value:e.toTex(t.eqXy)},null,8,["value"])])],64)}var $=h(k,[["render",L],["__file","NPlexMatrixRepresentation.vue"]]);export{$ as default};
